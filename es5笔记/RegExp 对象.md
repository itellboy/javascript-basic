# RegExp 对象 (3)

> 正则表达式一种文本匹配的模式。[参考](http://javascript.ruanyifeng.com/stdlib/regexp.html#toc5)

## 新建正则表达式

```javascript
var regexp = new RegExp('xyz');

var regexp = /xyz/;
```

## 实例属性
* 只读属性，修饰符

```javascript
RegExp.prototype.ignoreCase  // 忽略大小写
RegExp.prototype.global  // 全局匹配
RegExp.prototype.multiline  // 多行模式匹配
```

* 其他属性

```javascript
RegExp.prototype.lastIndex  // 返回一个数值，表示下一次搜索开始的位置，可写，当使用 g 修饰符的时候，该属性才发挥作用
RegExp.prototype.source  // 返回正则表达式的字符串形式，不包括反斜杠，只读
```

可以通过手动指定 `lastIndex` 属性来设置匹配的起始位置

## 实例方法

### RegExp.prototype.test

返回布尔值，当前模式是否匹配参数字符串

### RegExp.prototype.exec

* 正则匹配字符串，如果匹配上，返回包含结果的类数组的对象；如果没有结果，返回 `null`
* 返回类数组对象第一个成员为匹配成功的子串，第二个成员是圆括号匹配的结果
* 返回的类数组对象包含 `input` 和 `index` 两个属性，分别表示原字符串和匹配成功子串在原字符串的起始位置

## 字符串的实例方法

```javascript
String.prototype.match()  // 返回一个数组，包含所有匹配到的子串，没有返回 null
String.prototype.search()  // 返回一个整数，表示匹配成功开始的位置，没有返回 -1
String.prototype.replace()  // 按照给定的正则表达式替换字符串，返回替换后的字符串
String.prototype.split()  // 按照给定的正则表达式对字符串进行分割，返回一个包含分割后子串的数组
```

* 设置正则表达式的  `lastIndex` 属性，对 `match()` 方法无效，每次匹配都是从第 0 个位置开始的
* `replace()` 方法第二个参数可以是替换后的字符串，也可以是正则表达是的分组表达式 `$(1)` ，也可以是一个函数，替换每一个匹配的返回值
* `split()` 方法的第二个参数可以是一个数值，表示返回数组的最大成员数

## 匹配规则

### 字面量字符

> 在正则表达式中，某个字符只表示它字面的含义，比如 `/z/`, `/a/` 分别匹配 a 和 b，就叫他字面量字符

### 元字符

> 具有特殊含义的字符

#### 点字符 (.)

匹配除开回车 (`\r`)、换行 (`\n`)、行分割符 (`\u2028`) 和段分割符 (`\u2029`) 之外任意一个字符

#### 位置字符

* `^` 表示字符串的开始位置
* `$` 表示字符串的结束位置

#### 选择符 (|)

竖线符号 `|` 在正则表达式中，表示或 (`OR`) 的关系，可以联合使用

### 转义符 (\)

正则表达式中有一些特殊含义的元字符，如果要表达他们本身，则需要在字符前加上 `\` 进行转义

```javascript
/\+/.test('a+b');  // true
```

### 特殊字符

正则表达式为一些不能打印的字符，提供了一些表达方法

* `[\b]` 匹配退格键，不要与 `\b` 混淆
* `\n` 匹配换行键
* `\r` 匹配回车键
* `\t` 匹配制表符
* `\v` 匹配垂直制表符
* `\f` 匹配换页符
* `\0` 匹配 `null` 字符
* `\xhh` 匹配 `\u00` 和 `\uFF`
* `\uhhhh` 匹配 `\u0000` 和 `\uFFFF`

### 字符类

字符类 class 表示一些可供选择的字符，只要匹配一个就可以，把所有待匹配的字符放入方括号类，组成一个字符类， `/[abc]/` 可以匹配带有 a, b, c 字符的字符串

有两个字符在字符类中有特殊含义

#### 脱字符 (^)

* 表示除开方括号字符的任意字符都可以匹配，`[^abc]` 表示匹配除开 a, b, c 之外的任意字符
* [^] 表示匹配一切字符，范围比点字符 (.) 要大
* 脱字符只有在字符类的第一位才有效，否则就是字面字符

#### 连字符 (-)

* `/[0-9]/` 表示 `[0123456789]`
* `/[a-z]/` 表示 26 个小写字母
* `/[A-Z]/` 表示 26 个大写字母

### 预定义模式

> 常见匹配模式的简写

* `\d` 等同于 `[0-9]`
* `\D` 等同于 `[^0-9]`
* `\w` 等同于 `[a-zA-Z0-9_]`
* `\W` 等同于 `[^a-zA-Z0-9_]`
* `\s` 等同于 `[\r\n\t\v\f]`
* `\S` 等同于 `[^\r\n\t\v\f]`
* `\b` 匹配词的边界
* `\B` 匹配非词边界，即在词的内部

### 重复类

`a{n}` 匹配 a 字符重复 n 次

### 量字符

* `?` 匹配 0 次或 1 次，等同于 `{0, 1}`
* `*` 匹配 任意次，等同于 `{0,}`
* `+` 匹配 1 次或多次，等同于 `{1,}`

### 贪婪模式

* 量字符的原则是最大可能匹配，知道下一个字符不匹配为止，我们称这种匹配模式为贪婪模式
* 如果想讲贪婪模式改为非贪婪模式，则在量字符后面加上 `?`
* `*?` 表示某个模式出现 0 次或多次，采用非贪婪模式
* `+?` 表示某个模式出现 1 次或者多次匹配，采用非贪婪模式

### 修饰符

* `g` 修饰符，全局匹配，主要用于搜索和替换
* `i` 修饰符，忽略大小写进行匹配
* `m` 修饰符，多行匹配模式

### 组匹配

* 正则表达式的括号表示分组匹配，括号中的模式可以用来匹配分组的内容
* 使用组匹配的时候，不宜使用 `g` 修饰符，否则 `match()` 方法不回获取分组的内容，可以使用循环配合 `RegExp.prototype.exec()` 获取每一轮的组捕获
* 正则表达式内部可以使用 `\1`, `、2` ，来获取括号匹配的内容， `\1` 表示获取第一个括号匹配的内容

#### 非组捕获

`(?:x)` 称为非组捕获，表示不返回该组捕获的内容

```javascript
var m = 'abc'.match(/(?:.)b(.)/);
m // ["abc", "c"];
```

#### 先行断言

`x(?=y)` 称为先行断言，`x` 只有在 `y` 前面才匹配，`y` 不计入匹配结果

```javascript
var m = 'xy'.match(/x(?:y)/);
m // ['x']
```

#### 先行否定断言

`x(?!y)` 称为先行否定断言，只有不再 `y` 前面的 `x` 才匹配，`y` 不计入匹配结果

```javascript
var m = 'abcdca'.match(/c(?!a)/);
m // ['c']
```