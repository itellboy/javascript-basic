# 正则的扩展（1）

## RegExp 构造函数

RegExp 对象构造函数有两种方式

* 第一个参数为字符串，第二个参数为修饰符
* 第一个参数为正则表达式，第二个参数为修饰符，这种情况下，正则表达式后面的修饰符失效，并且这种方式在 ES5 下会报错

## 将字符串的正则方法全部定义在 RegExp 对象上面

* `String.prototype.match` 调用 `Regexp.prototype[Symbol.match]`
* `String.prototype.search` 调用 `Regexp.prototype[Symbol.search]`
* `String.prototype.split` 调用 `Regexp.prototype[Symbol.split]`
* `String.prototype.replace` 调用 `Regexp.ptototype[Symbol.replace]`


## u 修饰符

可以正确处理 4 个字节的 UTF-16 字符，主要修改了以下正则表达式的行为

* 点字符，加上 `u` 修饰符，可以正确匹配码点大于 `0xFFFF` 的字符
* unicode 字符表示法，ES6 新增了大括号表示 unicode 字符，如果采用这种表达式构建的正则，必须加上 `u` 修饰符，否则不能正确识别，会当作量字符解释
* 量词，加上 `u` 修饰符，所有的量词可以识别码点大于 `0xFFFF` 的字符
* 预定义模式，`/\S/` 可以正确识别码点大于 `0xFFFF` 的非空字符
* `i` 修饰符，有些相同的字符可以对应不同的 unicode 码，加上 `u` 修饰符，则可以正确匹配非规范的字符

## y 修饰符（用法待补充）

> 粘连 (sticky) 修饰符

* 和 `g` 修饰符类似，全局匹配。后一次匹配从前一次匹配成功的地方开始。不同的是， `y` 修饰符匹配必须从剩余的第一个位置开始匹配，这也就是 `粘连` 的含义

## sticky 属性

正则是否设置了 `y` 修饰符
## flags 属性

返回正则表达式的修饰符

## s 修饰符： dotAll 模式

* 点字符 `.` 不能正确匹配行终止符，包括回车、换行、制表符、垂直制表符，可以使用 `[^]` 作为替代方案
* ES2018 引入 `s` 修饰符，使得 `.` 可以匹配任意字符，这被称为 `dotAll` 模式，即点 (dot) 代表一切
* 与此同时引入了一个 `dotAll` 属性，返回一个布尔值，表示该模式是否处于 `dotAll` 模式

## 后行断言

* 在 ES5 中，JavaScript 只支持先行断言 (`/x(?=y)/`) ，和先行否定断言 (`/x(?!y)/`) ，不支持后行断言和后行否定断言
* ES2018 引入后行断言 （`/(?<=y)x/`）和后行否定断言 (`/(?<!y)x/`)

## unicode 属性类

* ES2018 引入了一种新的类的写法，`\p{...}` 和 `\P{...}` ，允许正则表达式匹配 unicode 某种属性的所有字？
* unicode 属性类要指定属性名和属性值， `/\p{UnicodePropertyName=UnicodePropertyValue}/`，对于部分属性，可以只写属性名或者属性值
* `\P{...}` 是 `\p{...}` 的反向匹配，即不满足条件的所有字符

## 具名组匹配

* ES2018 引入了具名组匹配，允许为每一个组匹配指定一个名字，便于代码的阅读，格式为 `?<name>`